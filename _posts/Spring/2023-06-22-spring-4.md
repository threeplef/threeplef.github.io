---
title: "[Spring] 2. Spring AOP"
excerpt: "관점지향 프로그래밍(Aspect Oriented Programming) 설명, 스프링의 AOP 프레임워크는 관점지향 프로그래밍을 훨씬 쉽고 간결하게 작성할 수 있도록 도와줌"

categories:
  - Spring
tags:
  - [Spring, Framework, Java, AOP]

toc: true
toc_sticky: true

date: 2023-06-22
last_modified_at: 2023-06-22
---

## 🌱 AOP 개요

### 1.1. AOP와 횡단 관점

1.  AOP 개요

- AOP는 문제를 바라보는 관점을 기준으로 프로그래밍하는 기법
- 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 관심 사항을 기준으로 프로그래밍함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와줌.
- AOP에서 중요한 개념은 **"「횡단 관점의 분리(Separation of Cross-Cutting Concern)」"**
- OOP를 더욱 OOP답게 만들어줌.

> 공통 관심 사항(cross-cutting concern)

    - 공통 기능으로 애플리케이션 전반에 걸쳐 필요한 기능
    - 예) 로깅, 트랜잭션, 보안 등

> 핵심 관심 사항(core concern)

    - 핵심 로직, 핵심 비즈니스 로직
    - 예) 계좌이체, 이자 계산, 대출 처리 등

2.  새로운 요구사항

- HelloService 클래스의 sayHello() 메서드가 실행되기 전에 HelloLog 클래스의 log() 메서드를 실행
  ![](https://github.com/threeplef/threeplef.github.io/assets/89235056/7213343f-8515-4804-83ec-0e93a738e27b)

  ```java
  package com.example.myapp.aop;

  public class HelloService implements IHelloService {

    @Override
    public String sayHello(String name) {
      System.out.println(">>>LOG: " + new.java.util.Date());
      String message = "Hello~~~" + name;
      return message;
    }

    @Override
    public String sayGoodbye(String name) {
      String message = "Goodbye~~~" + name;
      return message;
    }
  }
  ```

3.  횡단관점의 분리

- 관심사의 분리
  - OOP에서는 횡단관점 분리를 위해 공통 기능들을 하나의 클래스라는 단위로 모으고 그것들을 모듈로부터 분리함으로써 재사용성과 보수성을 높이고 있음.
    ![](https://github.com/threeplef/threeplef.github.io/assets/89235056/c607c03e-d0f0-432a-b4c1-5631a7d0ed7d)
- 관심사를 호출하는 핵심 코드
  - 각 모듈로부터 공통 기능으로 분리하는 것은 성공했지만 그 기능을 사용하기 위해 공통 기능을 호출하는 코드까지는 각 모듈로부터 분리할 수 없음. 그렇기 때문에 분리한 공통 기능을 이용하기 위한 코드가 각 모듈에 횡단으로 산재하게 됨.
    ![](https://github.com/threeplef/threeplef.github.io/assets/89235056/50ee959d-e6e6-4153-8b64-42387c7326ae)
- 횡단관점을 분리한 코드

  ```java
  // HelloLog.java
  package com.example.myapp.aop;

  public class HelloLog {
    // 공통 코드 분리!
    public static void log() {
      System.out.println(">>>LOG<<< : " + new java.util.Date());
    }
  }
  ```

  ```java
  @Override
  public String sayHello(String name) {
    HelloLog.log();  // 공통 코드를 호출하는 코드가 포함됨
    String message = "Hello~" + name;
    return message;
  }
  ```

4.  AOP 프레임워크

- AOP에서는 핵심 로직을 구현한 코드에서 공통 기능을 직접적으로 호출하지 않음.
- AOP에서는 분리한 공통 기능의 호출까지도 관점으로 다룸. 그리고 이러한 각 모듈로 산재한 관점을 횡단 관점이라 부름.
- AOP에서는 이러한 횡단 관점까지 분리함으로써 각 모듈로부터 관점에 관한 코드를 완전히 제거하는 것을 목표로 함.
  ![](https://github.com/threeplef/threeplef.github.io/assets/89235056/2e5ff540-1ab0-4079-a5da-d624138c4342)

### 1.2. 프록시 클래스를 이용한 AOP 구현

- HelloService 클래스의 sayHello() 메서드가 실행되기 전에 HelloLog 클래스의 log() 메서드를 실행

  ```java
  // HelloServiceProxy.java
  package com.example.myapp.aop;

  public class HelloServiceProxy extends HelloService {

    @Override
    public String sayHello(String name) {
      HelloLog.log();  // 핵심 코드 실행 전 공통 코드 실행
      String result = super.sayHello(name);  // 핵심 코드 실행
      return result;
    }
  }
  ```

### 1.3. AOP 용어

|     용어      |                                                                                                                                                    설명                                                                                                                                                     |                     예                      |
| :-----------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-----------------------------------------: |
| Target object |                                                                                                               하나 또는 그 이상의 Aspect에 의해 Advice되는 객체. 핵심 로직을 구현하는 클래스                                                                                                                |              HelloService 객체              |
|   JoinPoint   | 애플리케이션을 실행할 때 특정 작업이 시작될 수 있는 시점을 의미. 「클래스가 로드되는 시점」, 「인스턴스가 생성되는 시점」그리고 「메서드 호출 시점」 등이 조인포인트에 해당. 조인포인트는 어드바이스를 적용할 수 있는 시점들. 스프링에서는 프락시 기반 AOP를 지원하기 때문에 메서드 호출 조인포인트만 지원. | 모든 biz() 메서드, sayHello(), sayGoodbye() |
|   Pointcut    |                                                                         조인포인트의 부분집합. 실제로 어드바이스가 적용되는 조인포인트들을 의미. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 포인트컷을 정의할 수 있음.                                                                          |                 sayHello()                  |
|    Aspect     |                                                                                                                             여러 객체에 공통으로 적용되는 공통 관심 객체를 의미                                                                                                                             |                HelloLog 객체                |
|    Advice     |                                                                                핵심코드에 삽입되어 동작할 수 있는 공통코드와 시점을 의미. 어드바이스 시점은 before, after, after-throwing, after-returning, around 가 있음.                                                                                 |      ~전(before)에 log() 메서드를 실행      |
|    Weaving    |                                                                                                              Advice(공통코드)를 핵심코드에 삽입하는 것을 의미. 스프링은 런타임시 위빙을 지원.                                                                                                               |    HelloServiceProxy 클래스를 만드는 것     |

### 1.4. 위빙 방법

1. 컴파일시 위빙

   별도 컴파일러를 통해 핵심 관심사 모듈의 사이사이에 관점(Aspect) 형태로 만들어진 횡단 관심사 코드들이 삽입되어 관점이 적용된 최종 바이너리가 만들어지는 방식 (ex. AspectJ)

2. 클래스 로딩시 위빙

   별도의 Agent를 이용하여 JVM이 클래스를 로딩할 때 해당 클래스의 바이너리 정보를 변경함. 즉, Agent가 횡단 관심사 코드가 삽입된 바이너리 코드를 제공함으로써 AOP를 지원하게 됨. (ex. AspectWerkz)

3. 런타임시 위빙

   소스코드나 바이너리 파일의 변경 없이 프록시를 이용하여 AOP를 지원하는 방식. 프록시를 통해 핵심 관심사를 구현한 객체에 접근하게 되는데, 프록시는 핵심 관심사 실행 전후에 횡단 관심사를 실행함. 따라서 프록시 기반의 런타임 엮기의 경우 메서드 호출시에만 AOP를 적용할 수 있다는 제한점이 있음. (ex. Spring AOP)

### 1.5. Spring에서 AOP

- 스프링에서는 자체적으로 런타임시에 위빙하는 <u>프록시 기반의 AOP</u>를 지원하고 있음.
- 프록시 기반의 AOP는 <u>메서드 호출 조인포인트만 지원</u>
- 스프링에서 어떤 대상 객체에 대해 AOP를 적용할 지의 여부는 설정 파일을 통해서 지정
  - 스프링은 설정 정보를 이용하여 런타임에 대상 객체에 대한 프록시 객체를 생성하게 됨.
  - 따라서, 대상 객체를 직접 접근하는 것이 아니라 프록시를 통한 간접 접근을 하게 됨.
- 스프링은 완전한 AOP 기능을 제공하는 것이 목적이 아니라 엔터프라이즈 애플리케이션을 구현하는데 필요한 기능을 제공하는 것을 목적으로 하고 있음.
- 필드값 변경 등 다양한 조인포인트를 이용하려면 AspectJ와 같은 다른 AOP 솔루션을 이용해야 함.

---

<br>

[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
